{"mappings":"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","sources":["../../AppData/Local/Yarn/Data/global/node_modules/@parcel/scope-hoisting/lib/helpers.js","../../AppData/Local/Yarn/Data/global/node_modules/@parcel/runtime-js/lib/bundle-manifest.js","../../AppData/Local/Yarn/Data/global/node_modules/@parcel/runtime-js/lib/JSRuntime.js","./src/Vector2.ts","../../AppData/Local/Yarn/Data/global/node_modules/@parcel/runtime-js/lib/bundle-url.js","../../AppData/Local/Yarn/Data/global/node_modules/@parcel/runtime-js/lib/relative-path.js","./src/collisions.ts","./src/pool_table.ts"],"sourcesContent":["var $parcel$global =\n  typeof globalThis !== 'undefined'\n    ? globalThis\n    : typeof self !== 'undefined'\n    ? self\n    : typeof window !== 'undefined'\n    ? window\n    : typeof global !== 'undefined'\n    ? global\n    : {};\n\nfunction $parcel$interopDefault(a) {\n  return a && a.__esModule ? a.default : a;\n}\n\nfunction $parcel$defineInteropFlag(a) {\n  Object.defineProperty(a, '__esModule', {value: true});\n}\n\nfunction $parcel$export(e, n, v) {\n  Object.defineProperty(e, n, {get: v, enumerable: true});\n}\n\nfunction $parcel$exportWildcard(dest, source) {\n  Object.keys(source).forEach(function(key) {\n    if (key === 'default' || key === '__esModule') {\n      return;\n    }\n\n    Object.defineProperty(dest, key, {\n      enumerable: true,\n      get: function get() {\n        return source[key];\n      },\n    });\n  });\n\n  return dest;\n}\n\nfunction $parcel$missingModule(name) {\n  var err = new Error(\"Cannot find module '\" + name + \"'\");\n  err.code = 'MODULE_NOT_FOUND';\n  throw err;\n}\n","\"use strict\";\n\nvar mapping = {};\n\nfunction register(pairs) {\n  var keys = Object.keys(pairs);\n\n  for (var i = 0; i < keys.length; i++) {\n    mapping[keys[i]] = pairs[keys[i]];\n  }\n}\n\nfunction resolve(id) {\n  var resolved = mapping[id];\n\n  if (resolved == null) {\n    throw new Error('Could not resolve bundle with id ' + id);\n  }\n\n  return resolved;\n}\n\nmodule.exports.register = register;\nmodule.exports.resolve = resolve;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nfunction _plugin() {\n  const data = require(\"@parcel/plugin\");\n\n  _plugin = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _utils() {\n  const data = require(\"@parcel/utils\");\n\n  _utils = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _path() {\n  const data = _interopRequireDefault(require(\"path\"));\n\n  _path = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _nullthrows() {\n  const data = _interopRequireDefault(require(\"nullthrows\"));\n\n  _nullthrows = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// List of browsers that support dynamic import natively\n// https://caniuse.com/#feat=es6-module-dynamic-import\nconst DYNAMIC_IMPORT_BROWSERS = {\n  edge: '76',\n  firefox: '67',\n  chrome: '63',\n  safari: '11.1',\n  opera: '50'\n}; // Used for as=\"\" in preload/prefetch\n\nconst TYPE_TO_RESOURCE_PRIORITY = {\n  css: 'style',\n  js: 'script'\n};\nconst BROWSER_PRELOAD_LOADER = './loaders/browser/preload-loader';\nconst BROWSER_PREFETCH_LOADER = './loaders/browser/prefetch-loader';\nconst LOADERS = {\n  browser: {\n    css: './loaders/browser/css-loader',\n    html: './loaders/browser/html-loader',\n    js: './loaders/browser/js-loader',\n    wasm: './loaders/browser/wasm-loader',\n    IMPORT_POLYFILL: './loaders/browser/import-polyfill'\n  },\n  worker: {\n    js: './loaders/worker/js-loader',\n    wasm: './loaders/worker/wasm-loader',\n    IMPORT_POLYFILL: false\n  },\n  node: {\n    css: './loaders/node/css-loader',\n    html: './loaders/node/html-loader',\n    js: './loaders/node/js-loader',\n    wasm: './loaders/node/wasm-loader',\n    IMPORT_POLYFILL: null\n  }\n};\n\nfunction getLoaders(ctx) {\n  if (ctx.isWorker()) return LOADERS.worker;\n  if (ctx.isBrowser()) return LOADERS.browser;\n  if (ctx.isNode()) return LOADERS.node;\n  return null;\n} // This cache should be invalidated if new dependencies get added to the bundle without the bundle objects changing\n// This can happen when we reuse the BundleGraph between subsequent builds\n\n\nlet bundleDependencies = new WeakMap();\n\nvar _default = new (_plugin().Runtime)({\n  apply({\n    bundle,\n    bundleGraph,\n    options\n  }) {\n    // Dependency ids in code replaced with referenced bundle names\n    // Loader runtime added for bundle groups that don't have a native loader (e.g. HTML/CSS/Worker - isURL?),\n    // and which are not loaded by a parent bundle.\n    // Loaders also added for modules that were moved to a separate bundle because they are a different type\n    // (e.g. WASM, HTML). These should be preloaded prior to the bundle being executed. Replace the entry asset(s)\n    // with the preload module.\n    if (bundle.type !== 'js') {\n      return;\n    }\n\n    let {\n      asyncDependencies,\n      otherDependencies\n    } = getDependencies(bundle);\n    let assets = [];\n\n    for (let dependency of asyncDependencies) {\n      let resolved = bundleGraph.resolveAsyncDependency(dependency, bundle);\n\n      if (resolved == null) {\n        continue;\n      }\n\n      if (resolved.type === 'asset') {\n        if (!bundle.env.shouldScopeHoist) {\n          // If this bundle already has the asset this dependency references,\n          // return a simple runtime of `Promise.resolve(internalRequire(assetId))`.\n          // The linker handles this for scope-hoisting.\n          assets.push({\n            filePath: __filename,\n            code: `module.exports = Promise.resolve(module.bundle.root(${JSON.stringify(bundleGraph.getAssetPublicId(resolved.value))}))`,\n            dependency\n          });\n        }\n      } else {\n        let loaderRuntime = getLoaderRuntime({\n          bundle,\n          dependency,\n          bundleGraph,\n          bundleGroup: resolved.value,\n          options\n        });\n\n        if (loaderRuntime != null) {\n          assets.push(loaderRuntime);\n        }\n      }\n    }\n\n    for (let dependency of otherDependencies) {\n      // Resolve the dependency to a bundle. If inline, export the dependency id,\n      // which will be replaced with the contents of that bundle later.\n      let referencedBundle = bundleGraph.getReferencedBundle(dependency, bundle);\n\n      if (referencedBundle !== null && referencedBundle !== void 0 && referencedBundle.isInline) {\n        assets.push({\n          filePath: _path().default.join(__dirname, `/bundles/${referencedBundle.id}.js`),\n          code: `module.exports = ${JSON.stringify(dependency.id)};`,\n          dependency\n        });\n        continue;\n      } // Otherwise, try to resolve the dependency to an external bundle group\n      // and insert a URL to that bundle.\n\n\n      let resolved = bundleGraph.resolveAsyncDependency(dependency, bundle);\n\n      if (dependency.isURL && resolved == null) {\n        // If a URL dependency was not able to be resolved, add a runtime that\n        // exports the original moduleSpecifier.\n        assets.push({\n          filePath: __filename,\n          code: `module.exports = ${JSON.stringify(dependency.moduleSpecifier)}`,\n          dependency\n        });\n        continue;\n      }\n\n      if (resolved == null || resolved.type !== 'bundle_group') {\n        continue;\n      }\n\n      let bundleGroup = resolved.value;\n      let mainBundle = (0, _nullthrows().default)(bundleGraph.getBundlesInBundleGroup(bundleGroup).find(b => {\n        let entries = b.getEntryAssets();\n        return entries.some(e => bundleGroup.entryAssetId === e.id);\n      }));\n\n      if (bundle.env.outputFormat === 'commonjs' && mainBundle.type === 'js') {\n        assets.push({\n          filePath: __filename,\n          dependency,\n          code: `module.exports = require(\"./\" + ${getRelativePathExpr(bundle, mainBundle, options)})`\n        });\n        continue;\n      } // URL dependency or not, fall back to including a runtime that exports the url\n\n\n      assets.push(getURLRuntime(dependency, bundle, mainBundle, options));\n    } // In development, bundles can be created lazily. This means that the parent bundle may not\n    // know about all of the sibling bundles of a child when it is written for the first time.\n    // Therefore, we need to also ensure that the siblings are loaded when the child loads.\n\n\n    if (options.shouldBuildLazily && bundle.env.outputFormat === 'global') {\n      let referenced = bundleGraph.getReferencedBundles(bundle).filter(b => !b.isInline);\n\n      for (let referencedBundle of referenced) {\n        let loaders = getLoaders(bundle.env);\n\n        if (!loaders) {\n          continue;\n        }\n\n        let loader = loaders[referencedBundle.type];\n\n        if (!loader) {\n          continue;\n        }\n\n        let relativePathExpr = getRelativePathExpr(bundle, referencedBundle, options);\n        let loaderCode = `require(${JSON.stringify(loader)})(require('./bundle-url').getBundleURL() + ${relativePathExpr})`;\n        assets.push({\n          filePath: __filename,\n          code: loaderCode,\n          isEntry: true\n        });\n      }\n    }\n\n    if (shouldUseRuntimeManifest(bundle, options) && bundleGraph.getChildBundles(bundle).length > 0 && isNewContext(bundle, bundleGraph)) {\n      assets.push({\n        filePath: __filename,\n        code: getRegisterCode(bundle, bundleGraph),\n        isEntry: true\n      });\n    }\n\n    return assets;\n  }\n\n});\n\nexports.default = _default;\n\nfunction getDependencies(bundle) {\n  let cachedDependencies = bundleDependencies.get(bundle);\n\n  if (cachedDependencies) {\n    return cachedDependencies;\n  } else {\n    let asyncDependencies = [];\n    let otherDependencies = [];\n    bundle.traverse(node => {\n      if (node.type !== 'dependency') {\n        return;\n      }\n\n      let dependency = node.value;\n\n      if (dependency.isAsync && !dependency.isURL) {\n        asyncDependencies.push(dependency);\n      } else {\n        otherDependencies.push(dependency);\n      }\n    });\n    bundleDependencies.set(bundle, {\n      asyncDependencies,\n      otherDependencies\n    });\n    return {\n      asyncDependencies,\n      otherDependencies\n    };\n  }\n}\n\nfunction getLoaderRuntime({\n  bundle,\n  dependency,\n  bundleGroup,\n  bundleGraph,\n  options\n}) {\n  let loaders = getLoaders(bundle.env);\n\n  if (loaders == null) {\n    return;\n  }\n\n  let externalBundles = bundleGraph.getBundlesInBundleGroup(bundleGroup).filter(bundle => !bundle.isInline);\n  let mainBundle = (0, _nullthrows().default)(externalBundles.find(bundle => {\n    var _bundle$getMainEntry;\n\n    return ((_bundle$getMainEntry = bundle.getMainEntry()) === null || _bundle$getMainEntry === void 0 ? void 0 : _bundle$getMainEntry.id) === bundleGroup.entryAssetId;\n  })); // CommonJS is a synchronous module system, so there is no need to load bundles in parallel.\n  // Importing of the other bundles will be handled by the bundle group entry.\n  // Do the same thing in library mode for ES modules, as we are building for another bundler\n  // and the imports for sibling bundles will be in the target bundle.\n  // Also do this when building lazily or the runtime itself could get deduplicated and only\n  // exist in the parent. This causes errors if an old version of the parent without the runtime\n  // is already loaded.\n\n  if (bundle.env.outputFormat === 'commonjs' || bundle.env.isLibrary || options.shouldBuildLazily) {\n    externalBundles = [mainBundle];\n  } else {\n    // Otherwise, load the bundle group entry after the others.\n    externalBundles.splice(externalBundles.indexOf(mainBundle), 1);\n    externalBundles.reverse().push(mainBundle);\n  } // Determine if we need to add a dynamic import() polyfill, or if all target browsers support it natively.\n\n\n  let needsDynamicImportPolyfill = false;\n\n  if (bundle.env.isBrowser() && bundle.env.outputFormat === 'esmodule') {\n    needsDynamicImportPolyfill = !bundle.env.matchesEngines(DYNAMIC_IMPORT_BROWSERS);\n  }\n\n  let loaderModules = externalBundles.map(to => {\n    let loader = loaders[to.type];\n\n    if (!loader) {\n      return;\n    }\n\n    let relativePathExpr = getRelativePathExpr(bundle, to, options); // Use esmodule loader if possible\n\n    if (to.type === 'js' && to.env.outputFormat === 'esmodule') {\n      if (!needsDynamicImportPolyfill) {\n        return `import(\"./\" + ${relativePathExpr})`;\n      }\n\n      loader = (0, _nullthrows().default)(loaders.IMPORT_POLYFILL, `No import() polyfill available for context '${bundle.env.context}'`);\n    } else if (to.type === 'js' && to.env.outputFormat === 'commonjs') {\n      return `Promise.resolve(require(\"./\" + ${relativePathExpr}))`;\n    }\n\n    let code = `require(${JSON.stringify(loader)})(require('./bundle-url').getBundleURL() + ${relativePathExpr})`; // In development, clear the require cache when an error occurs so the\n    // user can try again (e.g. after fixing a build error).\n\n    if (options.mode === 'development' && bundle.env.outputFormat === 'global') {\n      code += '.catch(err => {delete module.bundle.cache[module.id]; throw err;})';\n    }\n\n    return code;\n  }).filter(Boolean);\n\n  if (bundle.env.context === 'browser' && !options.shouldBuildLazily) {\n    loaderModules.push(...externalBundles // TODO: Allow css to preload resources as well\n    .filter(to => to.type === 'js').flatMap(from => {\n      let {\n        preload,\n        prefetch\n      } = getHintedBundleGroups(bundleGraph, from);\n      return [...getHintLoaders(bundleGraph, bundle, preload, BROWSER_PRELOAD_LOADER, options), ...getHintLoaders(bundleGraph, bundle, prefetch, BROWSER_PREFETCH_LOADER, options)];\n    }));\n  }\n\n  if (loaderModules.length === 0) {\n    return;\n  }\n\n  let loaderCode = loaderModules.join(', ');\n\n  if (loaderModules.length > 1 && (bundle.env.outputFormat === 'global' || !externalBundles.every(b => b.type === 'js'))) {\n    loaderCode = `Promise.all([${loaderCode}])`;\n\n    if (bundle.env.outputFormat !== 'global') {\n      loaderCode += `.then(r => r[r.length - 1])`;\n    }\n  } else {\n    loaderCode = `(${loaderCode})`;\n  }\n\n  if (bundle.env.outputFormat === 'global' && mainBundle.type === 'js') {\n    loaderCode += `.then(() => module.bundle.root('${bundleGraph.getAssetPublicId(bundleGraph.getAssetById(bundleGroup.entryAssetId))}')${// In global output with scope hoisting, functions return exports are\n    // always returned. Otherwise, the exports are returned.\n    bundle.env.shouldScopeHoist ? '()' : ''})`;\n  }\n\n  return {\n    filePath: __filename,\n    code: `module.exports = ${loaderCode};`,\n    dependency\n  };\n}\n\nfunction getHintedBundleGroups(bundleGraph, bundle) {\n  let preload = [];\n  let prefetch = [];\n  let {\n    asyncDependencies\n  } = getDependencies(bundle);\n\n  for (let dependency of asyncDependencies) {\n    var _dependency$meta;\n\n    let attributes = (_dependency$meta = dependency.meta) === null || _dependency$meta === void 0 ? void 0 : _dependency$meta.importAttributes;\n\n    if (typeof attributes === 'object' && attributes != null && ( // $FlowFixMe\n    attributes.preload || attributes.prefetch)) {\n      let resolved = bundleGraph.resolveAsyncDependency(dependency, bundle);\n\n      if ((resolved === null || resolved === void 0 ? void 0 : resolved.type) === 'bundle_group') {\n        // === true for flow\n        if (attributes.preload === true) {\n          preload.push(resolved.value);\n        }\n\n        if (attributes.prefetch === true) {\n          prefetch.push(resolved.value);\n        }\n      }\n    }\n  }\n\n  return {\n    preload,\n    prefetch\n  };\n}\n\nfunction getHintLoaders(bundleGraph, from, bundleGroups, loader, options) {\n  let hintLoaders = [];\n\n  for (let bundleGroupToPreload of bundleGroups) {\n    let bundlesToPreload = bundleGraph.getBundlesInBundleGroup(bundleGroupToPreload);\n\n    for (let bundleToPreload of bundlesToPreload) {\n      let relativePathExpr = getRelativePathExpr(from, bundleToPreload, options);\n      let priority = TYPE_TO_RESOURCE_PRIORITY[bundleToPreload.type];\n      hintLoaders.push(`require(${JSON.stringify(loader)})(require('./bundle-url').getBundleURL() + ${relativePathExpr}, ${priority ? JSON.stringify(priority) : 'null'}, ${JSON.stringify(bundleToPreload.target.env.outputFormat === 'esmodule')})`);\n    }\n  }\n\n  return hintLoaders;\n}\n\nfunction isNewContext(bundle, bundleGraph) {\n  let parents = bundleGraph.getParentBundles(bundle);\n  return bundle.isEntry || parents.length === 0 || parents.some(parent => parent.env.context !== bundle.env.context || parent.type !== 'js');\n}\n\nfunction getURLRuntime(dependency, from, to, options) {\n  let relativePathExpr = getRelativePathExpr(from, to, options);\n\n  if (dependency.meta.webworker === true) {\n    return {\n      filePath: __filename,\n      code: `module.exports = require('./get-worker-url')(${relativePathExpr});`,\n      dependency\n    };\n  }\n\n  return {\n    filePath: __filename,\n    code: `module.exports = require('./bundle-url').getBundleURL() + ${relativePathExpr}`,\n    dependency\n  };\n}\n\nfunction getRegisterCode(entryBundle, bundleGraph) {\n  let idToName = {};\n  bundleGraph.traverseBundles((bundle, _, actions) => {\n    if (bundle.isInline) {\n      return;\n    }\n\n    idToName[bundle.publicId] = (0, _nullthrows().default)(bundle.name);\n\n    if (bundle !== entryBundle && isNewContext(bundle, bundleGraph)) {\n      // New contexts have their own manifests, so there's no need to continue.\n      actions.skipChildren();\n    }\n  }, entryBundle);\n  return \"require('./bundle-manifest').register(JSON.parse(\" + JSON.stringify(JSON.stringify(idToName)) + '));';\n}\n\nfunction getRelativePathExpr(from, to, options) {\n  if (shouldUseRuntimeManifest(from, options)) {\n    return `require('./relative-path')(${JSON.stringify(from.publicId)}, ${JSON.stringify(to.publicId)})`;\n  }\n\n  return JSON.stringify((0, _utils().relativeBundlePath)(from, to, {\n    leadingDotSlash: false\n  }));\n}\n\nfunction shouldUseRuntimeManifest(bundle, options) {\n  let env = bundle.env;\n  return !env.isLibrary && env.outputFormat === 'global' && env.isBrowser() && options.mode === 'production';\n}","export class Vector2 {\n  x: number;\n  y: number;\n\n  constructor(x = 0, y = 0) {\n    this.x = x;\n    this.y = y;\n  }\n\n  static distance(A: Vector2, B: Vector2): number {\n    return Math.sqrt(Math.pow(A.x - B.x, 2) + Math.pow(A.y - B.y, 2));\n  }\n\n  distance(V: Vector2): number {\n    return Math.sqrt(Math.pow(this.x - V.x, 2) + Math.pow(this.y - V.y, 2));\n  }\n\n  static distanceSq(A: Vector2, B: Vector2): number {\n    return Math.pow(A.x - B.x, 2) + Math.pow(A.y - B.y, 2);\n  }\n\n  magnitude(): number {\n    return Math.sqrt(Math.pow(this.x, 2) + Math.pow(this.y, 2));\n  }\n\n  normalize(): Vector2 {\n    let m = this.magnitude();\n\n    this.x /= m;\n    this.y /= m;\n\n    return this;\n  }\n\n  static add(A: Vector2, B: Vector2): Vector2 {\n    return new Vector2(A.x + B.x, A.y + B.y);\n  }\n\n  add(V: Vector2): void {\n    this.x += V.x;\n    this.y += V.y;\n  }\n\n  static subtract(A: Vector2, B: Vector2): Vector2 {\n    return new Vector2(A.x - B.x, A.y - B.y);\n  }\n\n  subtract(V: Vector2): Vector2 {\n    return new Vector2(this.x - V.x, this.y - V.y);\n  }\n\n  static divide(A: Vector2, B: Vector2): Vector2 {\n    return new Vector2(A.x / B.x, A.y / B.y);\n  }\n\n  static multiply(A: Vector2, B: Vector2): Vector2 {\n    return new Vector2(A.x * B.x, A.y * B.y);\n  }\n\n  multiply(V: Vector2): Vector2 {\n    return new Vector2(this.x * V.x, this.y * V.y);\n  }\n\n  static scale(A: Vector2, value: number): Vector2 {\n    return new Vector2(A.x * value, A.y * value);\n  }\n\n  scale(value: number): Vector2 {\n    return new Vector2(this.x * value, this.y * value);\n  }\n\n  static dot(A: Vector2, B: Vector2): number {\n    return A.x * B.x + A.y * B.y;\n  }\n\n  dot(V: Vector2): number {\n    return this.x * V.x + this.y * V.y;\n  }\n}\n","\"use strict\";\n\n/* globals document:readonly */\nvar bundleURL = null;\n\nfunction getBundleURLCached() {\n  if (!bundleURL) {\n    bundleURL = getBundleURL();\n  }\n\n  return bundleURL;\n}\n\nfunction getBundleURL() {\n  try {\n    throw new Error();\n  } catch (err) {\n    var matches = ('' + err.stack).match(/(https?|file|ftp):\\/\\/[^)\\n]+/g);\n\n    if (matches) {\n      return getBaseURL(matches[0]);\n    }\n  }\n\n  return '/';\n}\n\nfunction getBaseURL(url) {\n  return ('' + url).replace(/^((?:https?|file|ftp):\\/\\/.+)\\/[^/]+$/, '$1') + '/';\n} // TODO: Replace uses with `new URL(url).origin` when ie11 is no longer supported.\n\n\nfunction getOrigin(url) {\n  let matches = ('' + url).match(/(https?|file|ftp):\\/\\/[^/]+/);\n\n  if (!matches) {\n    throw new Error('Origin not found');\n  }\n\n  return matches[0];\n}\n\nexports.getBundleURL = getBundleURLCached;\nexports.getBaseURL = getBaseURL;\nexports.getOrigin = getOrigin;","\"use strict\";\n\nvar resolve = require('./bundle-manifest').resolve;\n\nmodule.exports = function (fromId, toId) {\n  return relative(dirname(resolve(fromId)), resolve(toId));\n};\n\nfunction dirname(_filePath) {\n  if (_filePath === '') {\n    return '.';\n  }\n\n  var filePath = _filePath[_filePath.length - 1] === '/' ? _filePath.slice(0, _filePath.length - 1) : _filePath;\n  var slashIndex = filePath.lastIndexOf('/');\n  return slashIndex === -1 ? '.' : filePath.slice(0, slashIndex);\n}\n\nfunction relative(from, to) {\n  if (from === to) {\n    return '';\n  }\n\n  var fromParts = from.split('/');\n\n  if (fromParts[0] === '.') {\n    fromParts.shift();\n  }\n\n  var toParts = to.split('/');\n\n  if (toParts[0] === '.') {\n    toParts.shift();\n  } // Find where path segments diverge.\n\n\n  var i;\n  var divergeIndex;\n\n  for (i = 0; (i < toParts.length || i < fromParts.length) && divergeIndex == null; i++) {\n    if (fromParts[i] !== toParts[i]) {\n      divergeIndex = i;\n    }\n  } // If there are segments from \"from\" beyond the point of divergence,\n  // return back up the path to that point using \"..\".\n\n\n  var parts = [];\n\n  for (i = 0; i < fromParts.length - divergeIndex; i++) {\n    parts.push('..');\n  } // If there are segments from \"to\" beyond the point of divergence,\n  // continue using the remaining segments.\n\n\n  if (toParts.length > divergeIndex) {\n    parts.push.apply(parts, toParts.slice(divergeIndex));\n  }\n\n  return parts.join('/');\n}\n\nmodule.exports._dirname = dirname;\nmodule.exports._relative = relative;","/* https://www.jeffreythompson.org/collision-detection/ */\n\nexport function circleRect(\n  cx: number,\n  cy: number,\n  radius: number,\n  rx: number,\n  ry: number,\n  rw: number,\n  rh: number\n): boolean {\n  // temporary variables to set edges for testing\n  let testX = cx;\n  let testY = cy;\n\n  // which edge is closest?\n  if (cx < rx) testX = rx;\n  // test left edge\n  else if (cx > rx + rw) testX = rx + rw; // right edge\n  if (cy < ry) testY = ry;\n  // top edge\n  else if (cy > ry + rh) testY = ry + rh; // bottom edge\n\n  // get distance from closest edges\n  let distX = cx - testX;\n  let distY = cy - testY;\n  let distance = Math.sqrt(distX * distX + distY * distY);\n\n  // if the distance is less than the radius, collision!\n  if (distance <= radius) {\n    return true;\n  }\n  return false;\n}\n\nexport function lineCircle(\n  x1: number,\n  y1: number,\n  x2: number,\n  y2: number,\n  cx: number,\n  cy: number,\n  r: number\n): boolean {\n  // is either end INSIDE the circle?\n  // if so, return true immediately\n  const inside1 = pointCircle(x1, y1, cx, cy, r);\n  const inside2 = pointCircle(x2, y2, cx, cy, r);\n  if (inside1 || inside2) return true;\n\n  // get length of the line\n  let distX = x1 - x2;\n  let distY = y1 - y2;\n  const len = Math.sqrt(distX * distX + distY * distY);\n\n  // get dot product of the line and circle\n  const dot =\n    ((cx - x1) * (x2 - x1) + (cy - y1) * (y2 - y1)) / Math.pow(len, 2);\n\n  // find the closest point on the line\n  const closestX = x1 + dot * (x2 - x1);\n  const closestY = y1 + dot * (y2 - y1);\n\n  // is this point actually on the line segment?\n  // if so keep going, but if not, return false\n  const onSegment = linePoint(x1, y1, x2, y2, closestX, closestY);\n  if (!onSegment) return false;\n\n  // optionally, draw a circle at the closest\n  // point on the line\n\n  // get distance to closest point\n  distX = closestX - cx;\n  distY = closestY - cy;\n  const distance = Math.sqrt(distX * distX + distY * distY);\n\n  if (distance <= r) {\n    return true;\n  }\n  return false;\n}\n\n// POINT/CIRCLE\nexport function pointCircle(\n  px: number,\n  py: number,\n  cx: number,\n  cy: number,\n  r\n): boolean {\n  // get distance between the point and circle's center\n  // using the Pythagorean Theorem\n  const distX = px - cx;\n  const distY = py - cy;\n  const distance = Math.sqrt(distX * distX + distY * distY);\n\n  // if the distance is less than the circle's\n  // radius the point is inside!\n  if (distance <= r) {\n    return true;\n  }\n  return false;\n}\n\n// LINE/POINT\nfunction linePoint(\n  x1: number,\n  y1: number,\n  x2: number,\n  y2: number,\n  px: number,\n  py: number\n): boolean {\n  // get distance from the point to the two ends of the line\n  const d1 = dist(px, py, x1, y1);\n  const d2 = dist(px, py, x2, y2);\n\n  // get the length of the line\n  const lineLen = dist(x1, y1, x2, y2);\n\n  // since floats are so minutely accurate, add\n  // a little buffer zone that will give collision\n  const buffer = 0.1; // higher # = less accurate\n\n  // if the two distances are equal to the line's\n  // length, the point is on the line!\n  // note we use the buffer here to give a range,\n  // rather than one #\n  if (d1 + d2 >= lineLen - buffer && d1 + d2 <= lineLen + buffer) {\n    return true;\n  }\n  return false;\n}\n\nfunction dist(x1: number, y1: number, x2: number, y2: number): number {\n  return Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));\n}\n\nexport function pointOfLinesIntersection(\n  x1: number,\n  y1: number,\n  x2: number,\n  y2: number,\n  x3: number,\n  y3: number,\n  x4: number,\n  y4: number\n): { x: number; y: number } | null {\n  // Check if none of the lines are of length 0\n  if ((x1 === x2 && y1 === y2) || (x3 === x4 && y3 === y4)) {\n    return null;\n  }\n\n  const denominator = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);\n\n  // Lines are parallel\n  if (denominator === 0) {\n    return null;\n  }\n\n  let ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / denominator;\n  let ub = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / denominator;\n\n  // is the intersection along the segments\n  if (ua < 0 || ua > 1 || ub < 0 || ub > 1) {\n    return null;\n  }\n\n  // Return a object with the x and y coordinates of the intersection\n  let x = x1 + ua * (x2 - x1);\n  let y = y1 + ua * (y2 - y1);\n\n  return { x, y };\n}\n","import { Vector2 } from \"./Vector2\";\n\nimport ball_8 from \"url:./assets/ball_8.png\";\nimport ball_16 from \"url:./assets/ball_16.png\";\nimport table from \"url:./assets/table.png\";\nimport { circleRect, lineCircle, pointOfLinesIntersection } from \"./collisions\";\n\nconst canvas = document.createElement(\"canvas\");\nconst ctx = canvas.getContext(\"2d\");\n\nconst W = 1030;\nconst H = 590;\n\nconst BUMPER_SIZE = 75;\n\nconst BALL_RADIUS = 14;\n\nconst PHYSICS_PRECISION = 10;\n\nconst FRICTION = 0.001;\n\ncanvas.width = W;\ncanvas.height = H;\n\ndocument.body.appendChild(canvas);\n\nif (!ctx) {\n  throw new Error(\"can't init 2d renderer\");\n}\n\nconst sprites = {\n  ball_8: {\n    src: ball_8,\n    sprite: null,\n  },\n  ball_16: {\n    src: ball_16,\n    sprite: null,\n  },\n  table: {\n    src: table,\n    sprite: null,\n  },\n};\n\nconst balls: Ball[] = [];\nconst pockets = [\n  { x: 59, y: 59, r: 32 },\n  { x: 59, y: H - 59, r: 32 },\n  { x: W - 59, y: 59, r: 32 },\n  { x: W - 59, y: H - 59, r: 32 },\n  { x: W / 2, y: 50, r: 25 },\n  { x: W / 2, y: H - 50, r: 25 },\n];\nconst bumpers = [\n  [82, 50, 106, 74],\n  [106, 74, 475, 74],\n  [475, 74, 489, 50],\n\n  [540, 50, 554, 74],\n  [554, 74, 922, 74],\n  [922, 74, 946, 50],\n\n  [979, 83, 955, 107],\n  [955, 107, 955, 482],\n  [955, 482, 979, 506],\n\n  [946, 539, 922, 515],\n  [922, 515, 554, 515],\n  [554, 515, 540, 539],\n\n  [489, 539, 475, 515],\n  [475, 515, 106, 515],\n  [106, 515, 84, 539],\n\n  [50, 506, 74, 482],\n  [74, 482, 74, 108],\n  [74, 108, 50, 84],\n];\n\nlet collision = null;\nconst update = (deltaTime: number): void => {\n  physics: for (let i = 1; i <= PHYSICS_PRECISION; i++) {\n    eachball: for (const ball of balls) {\n      const delta = ((deltaTime / PHYSICS_PRECISION) * i) / 1000;\n\n      const prevPos = new Vector2(ball.position.x, ball.position.y);\n\n      ball.position.add(Vector2.scale(ball.velocity, delta));\n\n      for (const { x, y, r } of pockets) {\n        if (Vector2.distance(ball.position, new Vector2(x, y)) <= r - 8) {\n          ball.destroy = true;\n          break physics;\n        }\n      }\n\n      const f = new Vector2();\n      const b = [];\n\n      for (const [x1, y1, x2, y2] of bumpers) {\n        if (\n          lineCircle(\n            x1,\n            y1,\n            x2,\n            y2,\n            ball.position.x,\n            ball.position.y,\n            BALL_RADIUS\n          )\n        ) {\n          b.push([x1, y1, x2, y2]);\n          // console.log(\n          //   \"colision!\",\n          //   lineCircle(x1, y1, x2, y2, prevPos.x, prevPos.y, BALL_RADIUS)\n          // );\n          // const dx = Math.sign(ball.velocity.x);\n          // const dy = Math.sign(ball.velocity.y);\n\n          // const forward = Vector2.add(\n          //   ball.position,\n          //   Vector2.scale(ball.velocity, 10)\n          // );\n\n          // // fix collision error;\n          // const p = pointOfLinesIntersection(\n          //   x1,\n          //   y1,\n          //   x2,\n          //   y2,\n          //   prevPos.x,\n          //   prevPos.y,\n          //   ball.position.x,\n          //   ball.position.y\n          // );\n\n          // console.log(p);\n\n          // calculate reflected velocity\n          const normal = new Vector2(y2 - y1, -(x2 - x1)).normalize();\n\n          f.add(normal);\n\n          // break;\n        }\n      }\n\n      if (f.x || f.y) {\n        f.normalize();\n        const dn = 2 * Vector2.dot(ball.velocity, f);\n        const r = Vector2.subtract(ball.velocity, Vector2.scale(f, dn));\n        ball.velocity = r;\n\n        while (\n          b.some(([x1, y1, x2, y2]) =>\n            lineCircle(\n              x1,\n              y1,\n              x2,\n              y2,\n              ball.position.x,\n              ball.position.y,\n              BALL_RADIUS\n            )\n          )\n        ) {\n          ball.position.add(Vector2.scale(ball.velocity, 0.01));\n        }\n      }\n\n      for (const otherBall of balls) {\n        if (ball === otherBall) continue;\n\n        if (ball.collisionProcessed || otherBall.collisionProcessed) continue;\n\n        if (\n          Vector2.distance(ball.position, otherBall.position) <\n          BALL_RADIUS * 2\n        ) {\n          const [x1, y1, x2, y2] = ellasticCollision2(\n            ball.position.x,\n            ball.position.y,\n            ball.velocity.x,\n            ball.velocity.y,\n            otherBall.position.x,\n            otherBall.position.y,\n            otherBall.velocity.x,\n            otherBall.velocity.y\n          );\n\n          ball.velocity = new Vector2(x1, y1);\n          otherBall.velocity = new Vector2(x2, y2);\n\n          while (\n            Vector2.distance(ball.position, otherBall.position) <\n            BALL_RADIUS * 2\n          ) {\n            ball.position.add(Vector2.scale(ball.velocity, 0.01));\n            otherBall.position.add(Vector2.scale(otherBall.velocity, 0.01));\n          }\n\n          ball.collisionProcessed = true;\n          otherBall.collisionProcessed = true;\n        }\n      }\n\n      ball.velocity.add(ball.acceleration);\n\n      if (ball.velocity.magnitude() < 0.001) {\n        ball.velocity.x = 0;\n        ball.velocity.y = 0;\n      }\n      ball.acceleration = new Vector2();\n      ball.acceleration.add(Vector2.scale(ball.velocity, -1 * FRICTION));\n    }\n  }\n\n  for (const ball of balls) {\n    ball.collisionProcessed = false;\n    if (ball.destroy) {\n      balls.splice(balls.indexOf(ball), 1);\n      // if (ball === whiteBall) {\n      // } else {\n      //   balls.splice(balls.indexOf(ball), 1);\n      //   balls.push(\n      //     new Ball(\n      //       Math.random() * (W - 200) + 100,\n      //       Math.random() * (H - 200) + 100,\n      //       Math.random() < 0.5 ? \"ball_8\" : \"ball_16\"\n      //     )\n      //   );\n      // }\n    }\n  }\n\n  // console.log(balls[0].velocity);\n};\n\nconst render = () => {\n  ctx.clearRect(0, 0, canvas.width, canvas.height);\n\n  ctx.drawImage(sprites.table.sprite, 0, 0, W, H);\n\n  // ctx.fillStyle = \"#f00f\";\n  // for (const [x1, y1, x2, y2] of bumpers) {\n  //   ctx.beginPath();\n  //   ctx.moveTo(x1, y1);\n  //   ctx.lineTo(x2, y2);\n  //   ctx.closePath();\n  //   ctx.stroke();\n  // }\n\n  ctx.strokeStyle = \"#fff\";\n  for (const ball of balls) {\n    ctx.drawImage(\n      sprites[ball.spriteName].sprite,\n      ball.l,\n      ball.t,\n      BALL_RADIUS * 2,\n      BALL_RADIUS * 2\n    );\n    // ctx.beginPath();\n    // ctx.moveTo(ball.position.x, ball.position.y);\n    // const forward = Vector2.add(\n    //   ball.position,\n    //   Vector2.scale(ball.velocity, 50)\n    // );\n    // ctx.lineTo(forward.x, forward.y);\n    // ctx.closePath();\n    // ctx.stroke();\n  }\n\n  // scope\n  if (mouse.pressed) {\n    // console.log(mouse);\n    ctx.strokeStyle = \"#fff\";\n    ctx.beginPath();\n    ctx.moveTo(whiteBall.position.x, whiteBall.position.y);\n    ctx.lineTo(\n      whiteBall.position.x + (mouse.x1 - mouse.x2),\n      whiteBall.position.y + (mouse.y1 - mouse.y2)\n    );\n    ctx.closePath();\n    ctx.stroke();\n  }\n};\n\nlet lastTick = Date.now();\nconst tick = () => {\n  if (collision) {\n    // render();\n    // const [a, b] = collision;\n    // const direction = Vector2.subtract(a.position, b.position);\n    // const aForward = Vector2.add(a.position, a.velocity);\n    // const bForward = Vector2.add(b.position, b.velocity);\n    // const aOrtho = new Vector2(direction.y, -direction.x)\n    //   .normalize()\n    //   .scale(100);\n    // const bOrtho = new Vector2(-direction.y, direction.x)\n    //   .normalize()\n    //   .scale(100);\n    // ctx.strokeStyle = \"blue\";\n    // ctx.beginPath();\n    // ctx.moveTo(a.position.x, a.position.y);\n    // ctx.lineTo(b.position.x, b.position.y);\n    // ctx.closePath();\n    // ctx.stroke();\n    // ctx.strokeStyle = \"yellow\";\n    // ctx.beginPath();\n    // ctx.moveTo(a.position.x, a.position.y);\n    // ctx.lineTo(aForward.x, aForward.y);\n    // ctx.closePath();\n    // ctx.stroke();\n    // ctx.beginPath();\n    // ctx.moveTo(a.position.x, a.position.y);\n    // ctx.lineTo(a.position.x + aOrtho.x, a.position.y + aOrtho.y);\n    // ctx.closePath();\n    // ctx.stroke();\n    // ctx.strokeStyle = \"red\";\n    // ctx.beginPath();\n    // ctx.moveTo(b.position.x, b.position.y);\n    // ctx.lineTo(bForward.x, bForward.y);\n    // ctx.closePath();\n    // ctx.stroke();\n    // ctx.beginPath();\n    // ctx.moveTo(b.position.x, b.position.y);\n    // ctx.lineTo(b.position.x + bOrtho.x, b.position.y + bOrtho.y);\n    // ctx.closePath();\n    // ctx.stroke();\n    // const [A1, B1] = ellasticCollision(\n    //   a.position,\n    //   a.velocity,\n    //   b.position,\n    //   b.velocity\n    // );\n    // console.log(A1, B1);\n  } else {\n    requestAnimationFrame(tick);\n    const now = Date.now();\n    const deltaTime = now - lastTick;\n    lastTick = now;\n\n    render();\n    update(deltaTime);\n  }\n};\n\nlet whiteBall: Ball;\nconst init = () => {\n  // for (let i = 0; i < 16; i++) {\n  //   balls.push(\n  //     new Ball(\n  //       Math.random() * (W - 200) + 100,\n  //       Math.random() * (H - 200) + 100,\n  //       Math.random() < 0.5 ? \"ball_8\" : \"ball_16\"\n  //     )\n  //   );\n  // }\n\n  balls.push(new Ball(W - 294 - BALL_RADIUS * 2, H / 2, \"ball_8\"));\n\n  balls.push(new Ball(W - 294, H / 2 - BALL_RADIUS, \"ball_8\"));\n  balls.push(new Ball(W - 294, H / 2 + BALL_RADIUS, \"ball_8\"));\n\n  balls.push(new Ball(W - 294 + BALL_RADIUS * 2, H / 2, \"ball_8\"));\n  balls.push(\n    new Ball(W - 294 + BALL_RADIUS * 2, H / 2 - BALL_RADIUS * 2, \"ball_8\")\n  );\n  balls.push(\n    new Ball(W - 294 + BALL_RADIUS * 2, H / 2 + BALL_RADIUS * 2, \"ball_8\")\n  );\n\n  balls.push(\n    new Ball(W - 294 + BALL_RADIUS * 4, H / 2 - BALL_RADIUS * 1, \"ball_8\")\n  );\n  balls.push(\n    new Ball(W - 294 + BALL_RADIUS * 4, H / 2 - BALL_RADIUS * 3, \"ball_8\")\n  );\n  balls.push(\n    new Ball(W - 294 + BALL_RADIUS * 4, H / 2 + BALL_RADIUS * 3, \"ball_8\")\n  );\n  balls.push(\n    new Ball(W - 294 + BALL_RADIUS * 4, H / 2 + BALL_RADIUS * 1, \"ball_8\")\n  );\n\n  whiteBall = new Ball(294, H / 2, \"ball_16\");\n\n  balls.push(whiteBall);\n\n  tick();\n};\n\nconst preload = () => {\n  return Promise.all<void>(\n    Object.keys(sprites).map((name) => {\n      return new Promise<void>((resolve, reject) => {\n        const img = new Image();\n        img.onload = () => {\n          sprites[name].sprite = img;\n          resolve();\n        };\n        img.onerror = () => {\n          reject();\n        };\n        img.src = sprites[name].src;\n      });\n    })\n  );\n};\n\nclass Ball {\n  position: Vector2;\n  velocity: Vector2;\n  acceleration: Vector2;\n  spriteName: string;\n  destroy: boolean = false;\n  collisionProcessed = false;\n\n  constructor(x, y, spriteName) {\n    this.position = new Vector2(x, y);\n    this.spriteName = spriteName;\n    this.velocity = new Vector2();\n    this.acceleration = new Vector2();\n  }\n\n  get l() {\n    return this.position.x - BALL_RADIUS;\n  }\n  get r() {\n    return this.position.x + BALL_RADIUS;\n  }\n  get t() {\n    return this.position.y - BALL_RADIUS;\n  }\n  get b() {\n    return this.position.y + BALL_RADIUS;\n  }\n}\n\npreload().then(init);\n\nconst ellasticCollision = (\n  p1: Vector2,\n  v1: Vector2,\n  p2: Vector2,\n  v2: Vector2\n): Vector2[] => {\n  const p12 = Vector2.subtract(p1, p2);\n  const d = Vector2.multiply(\n    Vector2.divide(Vector2.subtract(v1, v2), p12),\n    p12\n  );\n  return [Vector2.subtract(v1, d), Vector2.add(v2, d)];\n};\n\nconst ellasticCollision2 = (\n  x1,\n  y1,\n  x2,\n  y2,\n  x3,\n  y3,\n  x4,\n  y4,\n  u = (x3 -= x1) * x3 + (y3 -= y1) * y3,\n  v = x2 * x3 + y2 * y3 - x4 * x3 - y4 * y3\n) => [x2 - (x3 *= v / u), y2 - (v *= y3 / u), x4 + x3, y4 + v];\n\nlet mouse = {\n  pressed: false,\n  x1: 0,\n  y1: 0,\n  x2: 0,\n  y2: 0,\n};\ndocument.addEventListener(\"mousedown\", (e) => {\n  mouse.pressed = true;\n  mouse.x1 = e.pageX;\n  mouse.y1 = e.pageY;\n\n  mouse.x2 = e.pageX;\n  mouse.y2 = e.pageY;\n});\ndocument.addEventListener(\"mouseup\", () => {\n  mouse.pressed = false;\n\n  const direction = new Vector2(mouse.x1 - mouse.x2, mouse.y1 - mouse.y2);\n  whiteBall.velocity = direction;\n  // console.log(direction, direction.magnitude());\n});\ndocument.addEventListener(\"mousemove\", (e) => {\n  mouse.x2 = e.pageX;\n  mouse.y2 = e.pageY;\n});\n"],"names":["$parcel$interopDefault","a","__esModule","default","$1b85cbdb4a2643abd3c0934795ea3849$var$mapping","id","resolved","Error","pairs","keys","Object","i","length","JSON","parse","$9d368996530c9357592c7124010e8c65$export$Vector2","constructor","x","y","this","A","B","Math","sqrt","pow","distance","V","magnitude","normalize","m","add","subtract","multiply","value","scale","dot","$b6aed8b7805e73d5767ece3f2a7b8f9a$var$bundleURL","err","matches","stack","match","replace","$b6aed8b7805e73d5767ece3f2a7b8f9a$var$getBundleURL","$7f4d9277151e9a34254b64af6ed34253$var$resolve","$7f4d9277151e9a34254b64af6ed34253$var$dirname","_filePath","filePath","slice","slashIndex","lastIndexOf","$7f4d9277151e9a34254b64af6ed34253$var$relative","from","to","fromParts","split","shift","divergeIndex","toParts","parts","push","apply","join","fromId","toId","_dirname","_relative","$6706a48c22b0c4d87c0be3524cac2517$export$lineCircle","x1","y1","x2","y2","cx","cy","r","inside1","$6706a48c22b0c4d87c0be3524cac2517$export$pointCircle","inside2","distX","distY","len","closestX","closestY","px","py","d1","$6706a48c22b0c4d87c0be3524cac2517$var$dist","d2","lineLen","buffer","$6706a48c22b0c4d87c0be3524cac2517$var$linePoint","onSegment","$5d42b57b1f9c902ece4af4f6832d6426$var$canvas","document","createElement","$5d42b57b1f9c902ece4af4f6832d6426$var$ctx","getContext","$5d42b57b1f9c902ece4af4f6832d6426$var$W","$5d42b57b1f9c902ece4af4f6832d6426$var$H","$5d42b57b1f9c902ece4af4f6832d6426$var$BALL_RADIUS","width","height","body","appendChild","$5d42b57b1f9c902ece4af4f6832d6426$var$sprites","ball_8","src","sprite","ball_16","table","$5d42b57b1f9c902ece4af4f6832d6426$var$balls","$5d42b57b1f9c902ece4af4f6832d6426$var$pockets","$5d42b57b1f9c902ece4af4f6832d6426$var$bumpers","$5d42b57b1f9c902ece4af4f6832d6426$var$lastTick","Date","now","$5d42b57b1f9c902ece4af4f6832d6426$var$tick","$5d42b57b1f9c902ece4af4f6832d6426$var$collision","requestAnimationFrame","deltaTime","clearRect","drawImage","strokeStyle","ball","spriteName","l","t","$5d42b57b1f9c902ece4af4f6832d6426$var$mouse","pressed","beginPath","moveTo","$5d42b57b1f9c902ece4af4f6832d6426$var$whiteBall","position","lineTo","closePath","stroke","$5d42b57b1f9c902ece4af4f6832d6426$var$render","physics","eachball","delta","prevPos","velocity","destroy","f","b","normal","dn","some","otherBall","collisionProcessed","$5d42b57b1f9c902ece4af4f6832d6426$var$ellasticCollision2","acceleration","splice","indexOf","$5d42b57b1f9c902ece4af4f6832d6426$var$update","$5d42b57b1f9c902ece4af4f6832d6426$var$Ball","Promise","all","map","name","resolve","reject","img","Image","onload","onerror","then","x3","y3","x4","y4","u","v","addEventListener","e","pageX","pageY","direction"],"version":3,"file":"index.1d1402d2.js.map"}